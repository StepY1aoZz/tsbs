package main

import (
	"bufio"
	"encoding/binary"
	"io"
	"log"
	"os"

	"github.com/timescale/tsbs/pkg/data"
	"github.com/timescale/tsbs/pkg/data/usecases/common"
	"github.com/timescale/tsbs/pkg/targets"
)

type fileDataSource struct {
	decoder decoder
}

func (f fileDataSource) NextItem() data.LoadedPoint {
	if f.decoder.hasNext() {
		return data.LoadedPoint{Data: f.decoder.getNext()}
	} else {
		return data.LoadedPoint{}
	}
}

func (f fileDataSource) Headers() *common.GeneratedDataHeaders {
	//TODO implement me
	panic("implement me")
}

type factory struct {
}

func (f factory) New() targets.Batch {
	return &batch{}
}

type batch struct {
	mst    string
	metric uint32
	row    uint32
	len    uint
	data   []byte
}

func (b *batch) Len() uint {
	return b.len
}

func (b *batch) Append(item data.LoadedPoint) {
	d := item.Data.([]byte)
	var offset uint32 = 0
	mst, offset := String(d, offset)
	b.mst = mst
	rowCnt, offset := Uint32(d, offset)
	b.row += rowCnt
	metricCnt, offset := Uint32(d, offset)
	b.metric += metricCnt
	b.data = d[offset:]
	b.len += 1
}

type decoder interface {
	hasNext() bool
	getNext() []byte
}

type fileDecoder struct {
	nextLen   int
	bufReader *bufio.Reader
}

func newFileDecoder(f *os.File) *fileDecoder {
	ptr := bytesPool.Get().(*[]byte)
	t := *ptr
	t = resize(t, 4)
	_, err := io.ReadFull(f, t)
	if err != nil {
		fatal("Error while reading file: %v", err)
	}
	magicNumber := binary.BigEndian.Uint32(t)
	if magicNumber != 0x1225 {
		fatal("Magic number not matching,this file is not generated by tsbs_preprocess_opengemini")
	}
	_, err = io.ReadFull(f, t)
	if err != nil {
		fatal("Error while reading file: %v", err)
	}
	compressMethod = int(binary.BigEndian.Uint32(t))
	reader := bufio.NewReaderSize(f, maxSize)
	t = t[:0]
	bytesPool.Put(&t)
	return &fileDecoder{
		bufReader: reader,
		nextLen:   0,
	}
}

func (f *fileDecoder) hasNext() bool {
	ptr := bytesPool.Get().(*[]byte)
	t := *ptr
	t = resize(t, 4)
	_, err := io.ReadFull(f.bufReader, t)
	if err != nil && err == io.EOF {
		return false
	}
	if err != nil {
		fatal(err.Error())
	}
	f.nextLen = int(binary.BigEndian.Uint32(t))
	if f.nextLen > maxSize {
		log.Printf("warning: current record is too large which is %d MB", f.nextLen>>20)
	}
	t = t[:0]
	bytesPool.Put(&t)
	return true
}

func (f *fileDecoder) getNext() []byte {
	ptr := bytesPool.Get().(*[]byte)
	buf := *ptr
	buf = resize(buf, f.nextLen)
	_, err := io.ReadFull(f.bufReader, buf)
	if err != nil {
		fatal(err.Error())
	}
	return buf
}

func Uint32(src []byte, offset uint32) (uint32, uint32) {
	i := binary.BigEndian.Uint32(src[offset : offset+4])
	return i, offset + 4

}

func Uint16(src []byte, offset uint32) (uint16, uint32) {
	i := binary.BigEndian.Uint16(src[offset : offset+2])
	return i, offset + 2
}

func String(src []byte, offset uint32) (string, uint32) {
	l, offset := Uint16(src, offset)
	if l == 0 {
		return "", 0
	}
	s := string(src[offset : offset+uint32(l)])
	return s, offset + uint32(l)
}

func resize(b []byte, n int) []byte {
	if nn := n - cap(b); nn > 0 {
		b = append(b[:cap(b)], make([]byte, nn)...)
	}
	return b[:n]
}
